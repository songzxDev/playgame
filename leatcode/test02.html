<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Leetcode 刷题</title>
</head>
<body>
<script type="text/javascript">
    /**
     * 455. 分发饼干：一个小朋友最多只能拥有一块饼干
     * @param {number[]} g
     * @param {number[]} s
     * @return {number}
     */
    const findContentChildren = function (g, s) {
        let res = 0;
        if (g.length * s.length === 0) return res;
        g.sort(function (a, b) {
            return a - b;
        });
        s.sort(function (a, b) {
            return a - b;
        });
        let [gMin, sMax] = [g[0], s[s.length - 1]];
        if (sMax < gMin) return 0;
        // 最大值
        let [i, j] = [0, 0];
        while (i < g.length && j < s.length) {
            if (g[i] <= s[j]) {
                res += 1;
                i += 1;
                j += 1;
            } else {
                j += 1;
            }
        }
        return res;
    };

    /**
     * 1029. 两地调度：
     * 公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]
     * 返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达
     * @param {number[][]} costs
     * @return {number}
     */
    const twoCitySchedCost = function (costs) {
        costs.sort(function (a, b) {
            return (a[0] - a[1]) - (b[0] - b[1]);
        });
        let [total, n] = [0, costs.length / 2];
        for (let i = 0; i < n; i++) {
            total += costs[i][0] + costs[i + n][1];
        }
        return total;
    };

    /**
     * 665. 非递减数列
     * @param {number[]} nums
     * @return {boolean}
     */
    const checkPossibility = function (nums) {
        if (nums.length <= 2) return true;
        if (nums.length === 3) {
            return !(nums[0] > nums[1] && nums[0] > nums[2] && nums[1] > nums[2]);
        }
        let n = 0;
        for (let i = 0; i < nums.length - 1; i++) {
            let [a, b] = [nums[i], nums[i + 1]];
            if (a > b) {
                n += 1;
                if (n > 1) return false;
                if (i - 1 > -1 && nums[i - 1] > b && i + 2 < nums.length && a > nums[i + 2]) {
                    return false;
                }
            }
        }
        return true;
    };

    /**
     * 1122. 数组的相对排序：arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中
     * 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾
     * @param {number[]} arr1
     * @param {number[]} arr2
     * @return {number[]}
     */
    const relativeSortArray = function (arr1, arr2) {
        let temp = [];
        for (let n2 of arr2) {
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] === n2) {
                    [arr1[i], arr1[arr1.length - 1],] = [arr1[arr1.length - 1], arr1[i],];
                    while (arr1[arr1.length - 1] === n2) temp.push(arr1.pop());
                }
            }
        }
        arr1.sort(function (a, b) {
            return a - b;
        });
        return temp.concat(arr1);
    };

    /**
     * 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
     * @param {number[]} digits
     * @return {number[]}
     */
    const plusOne = function (digits) {
        let i = digits.length - 1;
        for (let j = i; j >= 0; j--) {
            digits[j] += 1;
            digits[j] %= 10;
            if (digits[j] !== 0) {
                return digits;
            }
        }
        digits = Array.from({length: i + 2}, () => (0));
        digits[0] = 1;
        return digits;
    };

    /**
     * 118. 杨辉三角：给定一个非负整数 numRows，生成杨辉三角的前 numRows 行
     * @param {number} numRows
     * @return {number[][]}
     */
    const generate = function (numRows) {
        let myMap = [[]];
        if (numRows === 0) return [];
        myMap[0].push(1);
        for (let rowNum = 1; rowNum < numRows; rowNum++) {
            let row = [];
            let prevRow = myMap[rowNum - 1];
            row.push(1);
            for (let j = 1; j < rowNum; j++) {
                row.push(prevRow[j - 1] + prevRow[j]);
            }
            row.push(1);
            myMap.push(row);
        }
        return myMap;
    };

    /**
     * 1089. 复写零：给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移
     * @param {number[]} arr
     * @return {void} Do not return anything, modify arr in-place instead.
     */
    const duplicateZeros = function (arr) {
        let [n, i, j] = [arr.length, 0, 0];
        while (j < n) {
            if (arr[i] === 0) ++j;
            ++i;
            ++j;
        }
        --i;
        --j;
        while (i >= 0) {
            if (j < n) arr[j] = arr[i];
            if (arr[i] === 0) arr[--j] = arr[i];
            --i;
            --j;
        }
    };

    /**
     * 922. 按奇偶排序数组 II
     * @param {number[]} A
     * @return {number[]}
     */
    const sortArrayByParityII = function (A) {
        let j = 1;
        for (let i = 0; i < A.length; i += 2) {
            if (A[i] % 2 === 1) {
                while (A[j] % 2 === 1) {
                    j += 2;
                }
                [A[i], A[j]] = [A[j], A[i]];
            }
        }
        return A;
    };
    /**
     * 976. 三角形的最大周长（如果不能形成任何面积不为零的三角形，返回 0）
     * 给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长
     * @param {number[]} A
     * @return {number}
     */
    const largestPerimeter = function (A) {
        A.sort(function (a, b) {
            return a - b;
        });
        // 三条边组成三角形的面积非零的充分必要条件是 a + b > c
        for (let i = A.length - 3; i >= 0; --i) {
            let [a, b, c] = [A[i], A[i + 1], A[i + 2]];
            if (a + b > c) {
                return a + b + c;
            }
        }
        return 0;

    };

    /**
     * 350. 两个数组的交集 II
     * @param {number[]} nums1
     * @param {number[]} nums2
     * @return {number[]}
     */
    const intersect = function (nums1, nums2) {
        /*
        1.如果给定的数组已经排好序呢？你将如何优化你的算法？
        2.如果 nums1 的大小比 nums2 小很多，哪种方法更优？
        3.如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？
         */
        nums1.sort(function (a, b) {
            return a - b;
        });
        nums2.sort(function (a, b) {
            return a - b;
        });
        let [i, j] = [0, 0];
        let res = [];
        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] < nums2[j]) {
                i++;
            } else if (nums1[i] > nums2[j]) {
                j++;
            } else {
                res.push(nums1[i]);
                i += 1;
                j += 1;
            }
        }
        return res;
    };

    /**
     * 520. 检测大写字母
     * @param {string} word
     * @return {boolean}
     */
    const detectCapitalUse = function (word) {
        if (word.length === 1) return true;
        let [upper, lower] = [0, 0];
        if (word.charCodeAt(0) >= 97 && word.charCodeAt(word.length - 1) <= 90) return false;
        for (let i = 0; i < word.length; i++) {
            word.charCodeAt(i) <= 90 ? upper += 1 : lower += 1;
        }
        return (lower === word.length || upper === word.length || (upper === 1 && word.charCodeAt(0) <= 90));
    };

    /**
     * 7. 整数反转：数值范围为 [−2^31,  2^31 − 1]，反转后整数溢出那么就返回 0
     * 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转
     * @param {number} x
     * @return {number}
     */
    const reverse = function (x) {
        // -2147483648～2147483647
        if (Math.abs(x) <= 9) return x;
        const [INT_MIN, INT_MAX] = [Math.pow(-2, 31), Math.pow(2, 31) - 1];
        let rev = 0;
        while (x !== 0) {
            let pop = x % 10;
            x = parseInt(x / 10, 10);
            if (rev > INT_MAX / 10 || (rev === INT_MAX / 10 && pop === 7)) return 0;
            if (rev < INT_MIN / 10 || (rev === INT_MIN / 10 && pop === -8)) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    };

    /**
     * 9.回文数（不要将整数转为字符串）
     * 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
     * @param {number} x
     * @return {boolean}
     */
    const isPalindrome = function (x) {
        if (x >= 0 && x <= 9) return true;
        if (x < 0) return false;
        let div = 1;
        while (x / div >= 10) div *= 10;
        while (x > 0) {
            let [left, right] = [parseInt(x / div, 10), x % 10];
            if (left !== right) return false;
            x = parseInt((x % div) / 10, 10);
            div = parseInt(div / 100, 10);
        }
        return true;
    };

    /**
     * 53. 最大子序和
     * 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素）
     * @param {number[]} nums
     * @return {number}
     */
    const maxSubArray = function (nums) {
        /* 假设你是一个选择性遗忘的赌徒，数组表示你这几天来赢钱或者输钱，
        你用sum来表示这几天来的输赢，用ans来存储你手里赢到的最多的钱，
        如果昨天你手上还是输钱（sum < 0），你忘记它，明天继续赌钱；
        如果你手上是赢钱(sum > 0), 你记得，你继续赌钱；
        你记得你手气最好的时候 */
        if (nums.length === 1) return nums[0];
        let ans = nums[0];
        let sum = 0;
        for (let num of nums) {
            if (sum > 0) {
                sum += num;
            } else {
                sum = num;
            }
            ans = Math.max(ans, sum);
        }
        return ans;
    };

    /**
     * 198. 打家劫舍
     * @param {number[]} nums
     * @return {number}
     */
    const rob = function (nums) {
        if (nums.length === 1) return nums[0];
        if (nums.length === 0) return 0;
        let [even, odd] = [0, 0];
        for (let i = 0; i < nums.length; i += 2) {
            even += nums[i];
            even = Math.max(even, odd);
            odd += (nums[i + 1] || 0);
            odd = Math.max(even, odd);
        }
        return Math.max(even, odd);
    };

    /**
     * 303. 区域和检索 - 数组不可变
     * @param {number[]} nums
     */
    let NumArray = function (nums) {
        const NUMS = Symbol("nums");
        this.sums = Object.create(null);
        this.sums[0] = 0;
        this[NUMS] = nums;
        for (let i = 0; i < this[NUMS].length; i++) {
            this.sums[i + 1] = this.sums[i] + this[NUMS][i];
        }
    };

    /**
     * @param {number} i
     * @param {number} j
     * @return {number}
     */
    NumArray.prototype.sumRange = function (i, j) {
        return this.sums[j + 1] - this.sums[i];
    };

    /**
     * Your NumArray object will be instantiated and called as such:
     * var obj = new NumArray(nums)
     * var param_1 = obj.sumRange(i,j)
     */

    /**
     * 121. 买卖股票的最佳时机
     * @param {number[]} prices
     * @return {number}
     */
    const maxProfit = function (prices) {
        if (prices.length <= 1) return 0;
        let [minPrice, maxPrice] = [prices[0], 0];
        for (let price of prices) {
            if (price < minPrice) {
                minPrice = price;
            }
            if (price - minPrice > maxPrice) {
                maxPrice = price - minPrice;
            }
        }
        return maxPrice;
    };

    /**
     * 746. 使用最小花费爬楼梯
     * @param {number[]} cost
     * @return {number}
     */
    const minCostClimbingStairs = function (cost) {
        // 状态转移方程： dp[i] = min(dp[i-1],dp[i-2]) + cost[i]
        if (cost.length === 2) return Math.min.apply(null, cost);
        let [p, q] = [cost[0], cost[1]];
        for (let i = 2; i < cost.length; i++) {
            let sum = Math.min(p, q) + cost[i];
            p = q;
            q = sum;
        }
        return Math.min(p, q);
    };

    /**
     * 1025. 除数博弈
     * @param {number} N
     * @return {boolean}
     */
    const divisorGame = function (N) {
        /*记dp[N]为黑板上数字为N的情况下,Alice的输赢情况， 如果Alice取了数字x, 那么显然dp[N]与dp[N -x]输赢情况相反。
        x可以取的值很多，只要dp[N -xi]中任意一个为False, 那么dp[N]肯定为True, 否则dp[N]为False*/
        let dp = Object.create(null);
        [dp[1], dp[2]] = [false, true];
        for (let i = 3; i < N + 1; i++) {
            dp[i] = false;
            for (let j = 1; j < i; j++) {
                if (i % j === 0 && dp[i - j] === false) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[N];
    };
</script>
</body>
</html>