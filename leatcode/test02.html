<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Leetcode 刷题</title>
</head>
<body>
<script type="text/javascript">
    /**
     * 455. 分发饼干：一个小朋友最多只能拥有一块饼干
     * @param {number[]} g
     * @param {number[]} s
     * @return {number}
     */
    const findContentChildren = function (g, s) {
        let res = 0;
        if (g.length * s.length === 0) return res;
        g.sort(function (a, b) {
            return a - b;
        });
        s.sort(function (a, b) {
            return a - b;
        });
        let [gMin, sMax] = [g[0], s[s.length - 1]];
        if (sMax < gMin) return 0;
        // 最大值
        let [i, j] = [0, 0];
        while (i < g.length && j < s.length) {
            if (g[i] <= s[j]) {
                res += 1;
                i += 1;
                j += 1;
            } else {
                j += 1;
            }
        }
        return res;
    };

    /**
     * 1029. 两地调度：
     * 公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]
     * 返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达
     * @param {number[][]} costs
     * @return {number}
     */
    const twoCitySchedCost = function (costs) {
        costs.sort(function (a, b) {
            return (a[0] - a[1]) - (b[0] - b[1]);
        });
        let [total, n] = [0, costs.length / 2];
        for (let i = 0; i < n; i++) {
            total += costs[i][0] + costs[i + n][1];
        }
        return total;
    };

    /**
     * 665. 非递减数列
     * @param {number[]} nums
     * @return {boolean}
     */
    const checkPossibility = function (nums) {
        if (nums.length <= 2) return true;
        if (nums.length === 3) {
            return !(nums[0] > nums[1] && nums[0] > nums[2] && nums[1] > nums[2]);
        }
        let n = 0;
        for (let i = 0; i < nums.length - 1; i++) {
            let [a, b] = [nums[i], nums[i + 1]];
            if (a > b) {
                n += 1;
                if (n > 1) return false;
                if (i - 1 > -1 && nums[i - 1] > b && i + 2 < nums.length && a > nums[i + 2]) {
                    return false;
                }
            }
        }
        return true;
    };

    /**
     * 1122. 数组的相对排序：arr2 中的元素各不相同，arr2 中的每个元素都出现在 arr1 中
     * 对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾
     * @param {number[]} arr1
     * @param {number[]} arr2
     * @return {number[]}
     */
    const relativeSortArray = function (arr1, arr2) {
        let temp = [];
        for (let n2 of arr2) {
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] === n2) {
                    [arr1[i], arr1[arr1.length - 1],] = [arr1[arr1.length - 1], arr1[i],];
                    while (arr1[arr1.length - 1] === n2) temp.push(arr1.pop());
                }
            }
        }
        arr1.sort(function (a, b) {
            return a - b;
        });
        return temp.concat(arr1);
    };

    /**
     * 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
     * @param {number[]} digits
     * @return {number[]}
     */
    const plusOne = function (digits) {
        let i = digits.length - 1;
        for (let j = i; j >= 0; j--) {
            digits[j] += 1;
            digits[j] %= 10;
            if (digits[j] !== 0) {
                return digits;
            }
        }
        digits = Array.from({length: i + 2}, () => (0));
        digits[0] = 1;
        return digits;
    };

    /**
     * 118. 杨辉三角：给定一个非负整数 numRows，生成杨辉三角的前 numRows 行
     * @param {number} numRows
     * @return {number[][]}
     */
    const generate = function (numRows) {
        let myMap = [[]];
        if (numRows === 0) return [];
        myMap[0].push(1);
        for (let rowNum = 1; rowNum < numRows; rowNum++) {
            let row = [];
            let prevRow = myMap[rowNum - 1];
            row.push(1);
            for (let j = 1; j < rowNum; j++) {
                row.push(prevRow[j - 1] + prevRow[j]);
            }
            row.push(1);
            myMap.push(row);
        }
        return myMap;
    };

    /**
     * 1089. 复写零：给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移
     * @param {number[]} arr
     * @return {void} Do not return anything, modify arr in-place instead.
     */
    const duplicateZeros = function (arr) {
        let [n, i, j] = [arr.length, 0, 0];
        while (j < n) {
            if (arr[i] === 0) ++j;
            ++i;
            ++j;
        }
        --i;
        --j;
        while (i >= 0) {
            if (j < n) arr[j] = arr[i];
            if (arr[i] === 0) arr[--j] = arr[i];
            --i;
            --j;
        }
    };

    /**
     * 922. 按奇偶排序数组 II
     * @param {number[]} A
     * @return {number[]}
     */
    const sortArrayByParityII = function (A) {
        let j = 1;
        for (let i = 0; i < A.length; i += 2) {
            if (A[i] % 2 === 1) {
                while (A[j] % 2 === 1) {
                    j += 2;
                }
                [A[i], A[j]] = [A[j], A[i]];
            }
        }
        return A;
    };
    /**
     * 976. 三角形的最大周长（如果不能形成任何面积不为零的三角形，返回 0）
     * 给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长
     * @param {number[]} A
     * @return {number}
     */
    const largestPerimeter = function (A) {
        A.sort(function (a, b) {
            return a - b;
        });
        // 三条边组成三角形的面积非零的充分必要条件是 a + b > c
        for (let i = A.length - 3; i >= 0; --i) {
            let [a, b, c] = [A[i], A[i + 1], A[i + 2]];
            if (a + b > c) {
                return a + b + c;
            }
        }
        return 0;

    };

    /**
     * 350. 两个数组的交集 II
     * @param {number[]} nums1
     * @param {number[]} nums2
     * @return {number[]}
     */
    const intersect = function (nums1, nums2) {
        /*
        1.如果给定的数组已经排好序呢？你将如何优化你的算法？
        2.如果 nums1 的大小比 nums2 小很多，哪种方法更优？
        3.如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？
         */
        nums1.sort(function (a, b) {
            return a - b;
        });
        nums2.sort(function (a, b) {
            return a - b;
        });
        let [i, j] = [0, 0];
        let res = [];
        while (i < nums1.length && j < nums2.length) {
            if (nums1[i] < nums2[j]) {
                i++;
            } else if (nums1[i] > nums2[j]) {
                j++;
            } else {
                res.push(nums1[i]);
                i += 1;
                j += 1;
            }
        }
        return res;
    };

    /**
     * 520. 检测大写字母
     * @param {string} word
     * @return {boolean}
     */
    const detectCapitalUse = function (word) {
        if (word.length === 1) return true;
        let [upper, lower] = [0, 0];
        if (word.charCodeAt(0) >= 97 && word.charCodeAt(word.length - 1) <= 90) return false;
        for (let i = 0; i < word.length; i++) {
            word.charCodeAt(i) <= 90 ? upper += 1 : lower += 1;
        }
        return (lower === word.length || upper === word.length || (upper === 1 && word.charCodeAt(0) <= 90));
    };

    /**
     * 7. 整数反转：数值范围为 [−2^31,  2^31 − 1]，反转后整数溢出那么就返回 0
     * 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转
     * @param {number} x
     * @return {number}
     */
    const reverse = function (x) {
        // -2147483648～2147483647
        const [INT_MIN, INT_MAX] = [Math.pow(-2, 31), Math.pow(2, 31) - 1];
        let rev = 0;
        while (x !== 0) {
            let pop = x % 10;
            x = parseInt(x / 10, 10);
            if (rev > INT_MAX / 10 || rev === INT_MAX && pop === 7) return 0;
            if (rev < INT_MIN / 10 || rev === INT_MIN && pop === -8) return 0;
            rev = rev * 10 + pop;
        }
        return rev;
    };
</script>
</body>
</html>